# Author: Nuno Aguiar
help:
  text   : Converts input __pm map (or stdin) into a OpenMetrics format and optionally send it to a gateway.
  expects: 
  - name     : prefix
    desc     : The metrics prefix to use
    example  : test
    mandatory: false
  - name     : joburl
    desc     : The prometheus gateway equivalent job url (e.g. http://gw:9091/metrics/job/myjob)
    example  : http://gw:9091/metrics/job/myjob
    mandatory: false
  - name     : timestamp
    desc     : If "timestamp=true" it will include the timestamp of when the data was produced. If timefield is not defined it uses the current time.
    example  : "true"
    mandatory: false
  - name     : timefield
    desc     : The JSON path to the field from where to derive the timestamp if timestamp=true (the field will be removed from the metrics data)
    example  : "__ts"
    mandatory: false
  - name     : timeadjust
    desc     : Number of seconds, positive or negative, to adjust the timefield value if needed.
    example  : 1468800
    mandatory: false
  - name     : filter
    desc     : Comma-delimited list of labels to ignore in the resulting openmetrics output
    example  : "_id,date"
    mandatory: false
  - name     : path
    desc     : A JSON path to assume for each entry
    example  : values
    mandatory: false
  - name     : convertValues
    desc     : If "true" it will convert the values with units (e.g. 10ms) to numbers
    example  : "true"
    mandatory: false
  - name     : folder
    desc     : A path to ndjson files to process (gzip or not)
    example  : /my/folder
    mandatory: false

todo:
- (if    ): "isDef(args.folder)"
  ((then)):
  - Convert folder to OpenMetrics
  ((else)):
  - Convert to OpenMetrics

ojob:
  opacks      :
  - openaf: 20231014
  catch       : &CATCH printErrnl("[" + job.name + "] "); if (isDef(exception.javaException)) exception.javaException.printStackTrace(); else printErr(exception)
  logToConsole: true   # to change when finished
        

jobs:
# -----------------------
- name : Parsing function
  check:
    in:
      prefix       : isString.default(__)
      timestamp    : toBoolean.isBoolean.default(false)
      timeadjust   : toNumber.isNumber.default(0)
      timefield    : isString.default(__)
      filter       : isString.default("")
      path         : isString.default("")
      convertValues: toBoolean.isBoolean.default(false)
  exec : |
    ow.loadMetrics()
    global._filterLabels = args.filter.split(",")

    global.parseData = function(data, returnFile) {
      if (!isMap(data) && !isArray(data)) data = jsonParse(String(data), true)

      var _ts = (args.timestamp ? (isUnDef(args.timefield) ? new Date() : new Date($$(data).get(args.timefield))) : __)

      // If path is defined get specific data
      var _data = $$(data).get(args.path)

      // Convert values
      if (args.convertValues) {
        traverse(_data, (aK, aV, aP, aO) => {
          // Remove spaces in numbers
          if (isString(aV) && /([0-9]+ )+/.test(aV)) aO[aK] = aV.replace(/ /g, "") 

          if (isString(aV) && aV.indexOf(":") < 0 && /\d+ *[a-z]+$/i.test(aV)) {
            var _ar = aV.match(/[a-z]+$/)
            var _u = _ar[0].toUpperCase()
            if (['BYTES', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB', 'KIB', 'MIB', 'GIB', 'TIB', 'PIB', 'EIB', 'ZIB', 'YIB', 'KI', 'MI', 'GI', 'TI', 'PI', 'EI', 'ZI', 'YI'].indexOf(_u) >= 0) {
              // Its a bytes abbreviation
              aO[aK] = ow.format.fromBytesAbbreviation(aV)
              return
            }
            // Ignoring month 'M' alone to avoid conflict with SI
            if (['MS', 'S', 'H', 'D', 'W', 'Y'].indexOf(_u) >= 0 || (['M'].indexOf(_u) >= 0 && aV.indexOf(" ") > 0)) {
              // Its a time abbreviation
              aO[aK] = ow.format.fromTimeAbbreviation(aV)
              return
            }
            if (["da","h","k","M","G","T","P","E","Z","Y","R","Q","d","c","m","Î¼","n","p","f","a","z","y","r","q"].indexOf(_ar[0]) >= 0) {
              // Its a SI abbreviation
              aO[aK] = ow.format.fromSIAbbreviation(aV)
              return
            }
          }
        })
      }

      // Remove nulls
      var _ov = __flags.ALTERNATIVES.traverse
      __flags.ALTERNATIVES.traverse = false
      traverse(_data, (aK, aV, aP, aO) => {
        if (isNull(aV)) delete aO[aK]
      })
      __flags.ALTERNATIVES.traverse = _ov

      var out = ow.metrics.fromObj2OpenMetrics(_data, args.prefix, isDef(_ts) ? Number(Math.round(_ts.getTime() / 1000) + args.timeadjust) : __ )
 
      // Filter labels
      global._filterLabels.forEach(l => {
        var _l = l.trim()
        out = out.replace(new RegExp("([{,])" + _l + "=\"[^\"]*\"([},])", "g"), "$1$2").replace(/,+/g, ",").replace(/,}/g, "}")
      })
      
      if (isDef(args.joburl)) {
        var res = $rest().post(args.joburl, out)
        if (isDef(res.error)) {
          printErr(res.error.response)
        }
        print("Sent " + out.length + " bytes to " + args.joburl)
      } else {
        if (isString(returnFile)) {
          io.writeFileString(returnFile, out, __, true)
        } else {
          printnl(out)
        }
      }
    }

# -----------------------------
- name : Convert to OpenMetrics
  from : 
  - Parsing function
  exec : |
    var data = __pm

    if (isDef(__pm._map)) data = __pm._map
    if (isDef(__pm._list)) data = __pm._list

    if (Object.keys(data).length == 0) {
      io.pipeLn(global.parseData)
    } else {
      global.parseData(data)
    }

# ------------------------------------
- name : Convert folder to OpenMetrics
  from :
  - Parsing function
  each : 
  - Convert ndjson file
  check:
    in:
      folder: isString.default(__)
  exec : |
    $from(listFilesRecursive(args.folder))
    .ends("filename", ".ndjson")
    .orEnds("filename", ".ndjson.gz")
    .sort("filename")
    .select(file => {
      tlog("Processing {{filepath}}...", file)
      var _target = file.canonicalPath.replace(/\.ndjson(.gz)?$/, ".openmetrics")
      io.rm(_target)
      each(merge(args, { source: file.canonicalPath, target: _target }))
    })

# --------------------------
- name : Convert ndjson file
  catch: *CATCH
  check:
    in:
      source: isString 
      target: isString
  exec : |
    var is
    if (args.source.endsWith(".gz")) {
      is = io.readFileGzipStream(args.source)
    } else {
      is = io.readFileStream(args.source)
    }
  
    tlog("Converting {{source}} to {{target}}...", args)
    io.readLinesNDJSON(is, line => {
      try {
        global.parseData(line, args.target)
      } catch(e) {
        tprintErr("Error parsing file {{source}}: {{{e}}}", merge(args, { e: e }))
        exit(0, true)
      }
    })

    is.close()
