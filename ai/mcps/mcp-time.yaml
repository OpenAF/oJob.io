# Author: OpenAI Assistant
help:
  text   : A STDIO/HTTP MCP time and timezone utility server
  expects:
  - name     : onport
    desc     : If defined starts a MCP server on the provided port
    example  : "8888"
    mandatory: false

todo:
- (if    ): "isDef(args.onport)"
  ((then)):
  - (httpdStart   ): "${onport:-8080}"
  - (httpdHealthz ): "${onport:-8080}"
  - (httpdMetrics ): "${onport:-8080}"
  - (httpdMCP     ): "${onport:-8080}"
    ((description)): &MCPSERVER
      serverInfo:
        name   : mini-a-time
        title  : OpenAF mini-a MCP time and timezone utility server
        version: 1.0.0
    ((fnsMeta)): &MCPFNSMETA
      current-time:
        name       : current-time
        description: Returns the current date and time information, optionally for a specific timezone.
        inputSchema:
          type      : object
          properties:
            timezone:
              type        : string
              description : IANA timezone identifier to use instead of the system default.
              example     : "Europe/Lisbon"
            format:
              type        : string
              description : Optional Java time pattern used to produce the formatted field.
              example     : "yyyy-MM-dd HH:mm:ss"
            locale:
              type        : string
              description : Optional BCP 47 language tag to format locale-aware fields.
              example     : "en-US"
          required: []
        annotations:
          title         : current-time
          readOnlyHint  : true
          idempotentHint: true

      timezone-tools:
        name       : timezone-tools
        description: Performs timezone conversions, offset comparisons, or listings depending on the requested operation.
        inputSchema:
          type      : object
          properties:
            operation:
              type        : string
              description : Operation to perform. Supported values are convert, difference, and list.
              enum        : [ convert, difference, list ]
            targetTimezone:
              type        : string
              description : Target IANA timezone identifier (required for operation=convert).
              example     : "America/New_York"
            sourceTimezone:
              type        : string
              description : Source IANA timezone identifier (defaults to the system timezone when omitted).
              example     : "Europe/Lisbon"
            datetime:
              type        : string
              description : Date/time reference (convert/difference). Defaults to the current moment when omitted.
              example     : "2024-06-01T10:15:00"
            inputFormat:
              type        : string
              description : Optional Java time pattern when parsing datetimes without timezone offsets.
              example     : "yyyy-MM-dd'T'HH:mm:ss"
            outputFormat:
              type        : string
              description : Optional Java time pattern used to format the convert output.
              example     : "EEE, dd MMM yyyy HH:mm z"
            firstTimezone:
              type        : string
              description : First IANA timezone identifier (required for operation=difference).
              example     : "Europe/London"
            secondTimezone:
              type        : string
              description : Second IANA timezone identifier (required for operation=difference).
              example     : "Asia/Tokyo"
            locale:
              type        : string
              description : Optional BCP 47 language tag applied to parsing/formatting (convert/difference).
              example     : "en-US"
            search:
              type        : string
              description : Case-insensitive substring filter used when listing timezones.
              example     : "America"
          required: [ operation ]
        annotations:
          title         : timezone-tools
          readOnlyHint  : true
          idempotentHint: true
      sleep:
        name       : sleep
        description: Pauses execution for the specified number of milliseconds.
        inputSchema:
          type      : object
          properties:
            milliseconds:
              type        : integer
              minimum     : 0
              description : Number of milliseconds to pause execution.
              example     : 1000
          required: [ milliseconds ]
        annotations:
          title         : sleep
          readOnlyHint  : false
          idempotentHint: false
    ((fns    )): &MCPFNS
      current-time   : Current time information
      timezone-tools : Timezone utilities
      sleep          : Sleep
  ((else)):
  - (stdioMCP ): *MCPSERVER
    ((fnsMeta)): *MCPFNSMETA
    ((fns    )): *MCPFNS

ojob:
  opacks      :
  - openaf     : 20250915
  - oJob-common: 20250914
  catch       : printErrnl("[" + job.name + "] "); $err(exception, __, __, job.exec)
  logToConsole: false   # to change when finished
  argsFromEnvs: true
  daemon      : true
  unique      :
    pidFile     : .mcp-time.pid
    killPrevious: true

include:
- oJobMCP.yaml

jobs:
# -------------------------------
- name : Current time information
  check:
    in:
      timezone: isString.default(__)
      format  : isString.default(__)
      locale  : isString.default(__)
  exec : | #js
    var ZoneId = java.time.ZoneId
    var ZonedDateTime = java.time.ZonedDateTime
    var DateTimeFormatter = java.time.format.DateTimeFormatter
    var ChronoUnit = java.time.temporal.ChronoUnit
    var IsoFields = java.time.temporal.IsoFields
    var TextStyle = java.time.format.TextStyle
    var Locale = java.util.Locale

    var zone = isDef(args.timezone) ? ZoneId.of(args.timezone) : ZoneId.systemDefault()
    var locale = isDef(args.locale) ? Locale.forLanguageTag(args.locale) : Locale.getDefault()
    var now = ZonedDateTime.now(zone)

    var pattern = isDef(args.format) ? args.format : "yyyy-MM-dd'T'HH:mm:ssXXX"
    var formatter = DateTimeFormatter.ofPattern(pattern).withLocale(locale)
    var timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss").withLocale(locale)

    var truncated = now.truncatedTo(ChronoUnit.SECONDS)
    var weekOfYear = now.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR)
    var weekYear = now.get(IsoFields.WEEK_BASED_YEAR)

    var offsetSeconds = Number(now.getOffset().getTotalSeconds())

    return {
      timezone              : String(zone.getId()),
      timezoneDisplay       : String(zone.getDisplayName(TextStyle.FULL, locale)),
      timezoneAbbreviation  : String(zone.getDisplayName(TextStyle.SHORT, locale)),
      offset                : String(now.getOffset()),
      offsetSeconds         : offsetSeconds,
      offsetHours           : Number(offsetSeconds / 3600),
      iso8601               : String(now.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
      zonedISO              : String(now.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)),
      formatted             : String(now.format(formatter)),
      date                  : String(now.toLocalDate()),
      time                  : String(truncated.format(timeFormatter)),
      unixEpochSeconds      : Number(now.toEpochSecond()),
      unixEpochMilliseconds : Number(now.toInstant().toEpochMilli()),
      dayOfWeek             : String(now.getDayOfWeek()),
      dayOfYear             : Number(now.getDayOfYear()),
      weekOfYear            : Number(weekOfYear),
      weekYear              : Number(weekYear),
      isDaylightSaving      : Boolean(zone.getRules().isDaylightSavings(now.toInstant())),
      locale                : String(locale.toLanguageTag())
    }

# -------------------------
- name : Timezone utilities
  check:
    in:
      operation     : isString
      targetTimezone: isString.default(__)
      sourceTimezone: isString.default(__)
      datetime      : isString.default(__)
      inputFormat   : isString.default(__)
      outputFormat  : isString.default(__)
      firstTimezone : isString.default(__)
      secondTimezone: isString.default(__)
      locale        : isString.default(__)
      search        : isString.default(__)
  exec : | #js
    var allowedOps = ["convert", "difference", "list"]
    var op = isDef(args.operation) ? String(args.operation).toLowerCase() : null
    if (isUnDef(op) || allowedOps.indexOf(op) < 0) {
      throw new Error("operation must be one of convert, difference, list")
    }

    if (op === "list") {
      var ZoneIdList = java.time.ZoneId
      var zones = ZoneIdList.getAvailableZoneIds().iterator()
      var list = []
      while (zones.hasNext()) {
        var id = String(zones.next())
        if (isDef(args.search)) {
          if (id.toLowerCase().indexOf(String(args.search).toLowerCase()) >= 0) {
            list.push(id)
          }
        } else {
          list.push(id)
        }
      }
      list.sort()
      return {
        operation : op,
        timezones : list
      }
    }

    var ZoneId = java.time.ZoneId
    var ZonedDateTime = java.time.ZonedDateTime
    var LocalDateTime = java.time.LocalDateTime
    var DateTimeFormatter = java.time.format.DateTimeFormatter
    var Locale = java.util.Locale
    var locale = isDef(args.locale) ? Locale.forLanguageTag(args.locale) : Locale.getDefault()

    if (op === "convert") {
      if (isUnDef(args.targetTimezone)) {
        throw new Error("targetTimezone is required for operation=convert")
      }

      var sourceZone = isDef(args.sourceTimezone) ? ZoneId.of(args.sourceTimezone) : ZoneId.systemDefault()
      var targetZone = ZoneId.of(args.targetTimezone)
      var formatterOut = isDef(args.outputFormat) ? DateTimeFormatter.ofPattern(args.outputFormat).withLocale(locale) : null

      function parseDateTime(value) {
        if (isUnDef(value) || value === null || value === "") {
          return ZonedDateTime.now(sourceZone)
        }

        if (isDef(args.inputFormat)) {
          var fmt = DateTimeFormatter.ofPattern(args.inputFormat).withLocale(locale)
          var local = LocalDateTime.parse(value, fmt)
          return local.atZone(sourceZone)
        }

        try {
          return ZonedDateTime.parse(value)
        } catch(e) {
          var local = LocalDateTime.parse(value)
          return local.atZone(sourceZone)
        }
      }

      var parsed = parseDateTime(args.datetime)
      var converted = parsed.withZoneSameInstant(targetZone)

      return {
        operation            : op,
        sourceTimezone       : String(sourceZone.getId()),
        targetTimezone       : String(targetZone.getId()),
        sourceIso8601        : String(parsed.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        targetIso8601        : String(converted.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        targetZonedISO       : String(converted.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)),
        formatted            : formatterOut ? String(converted.format(formatterOut)) : String(converted.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        sourceOffsetSeconds  : Number(parsed.getOffset().getTotalSeconds()),
        targetOffsetSeconds  : Number(converted.getOffset().getTotalSeconds()),
        unixEpochSeconds     : Number(converted.toEpochSecond()),
        unixEpochMilliseconds: Number(converted.toInstant().toEpochMilli())
      }
    }

    if (op === "difference") {
      if (isUnDef(args.firstTimezone) || isUnDef(args.secondTimezone)) {
        throw new Error("firstTimezone and secondTimezone are required for operation=difference")
      }

      var firstZone = ZoneId.of(args.firstTimezone)
      var secondZone = ZoneId.of(args.secondTimezone)

      function parseMoment(value) {
        if (isUnDef(value) || value === null || value === "") {
          return ZonedDateTime.now(firstZone)
        }

        if (isDef(args.inputFormat)) {
          var fmt = DateTimeFormatter.ofPattern(args.inputFormat).withLocale(locale)
          var local = LocalDateTime.parse(value, fmt)
          return local.atZone(firstZone)
        }

        try {
          return ZonedDateTime.parse(value)
        } catch(e) {
          var local = LocalDateTime.parse(value)
          return local.atZone(firstZone)
        }
      }

      var base = parseMoment(args.datetime)
      var instant = base.toInstant()

      var firstOffset = firstZone.getRules().getOffset(instant).getTotalSeconds()
      var secondOffset = secondZone.getRules().getOffset(instant).getTotalSeconds()
      var differenceSeconds = secondOffset - firstOffset
      var totalMinutes = Math.abs(differenceSeconds) / 60
      var hours = Math.floor(totalMinutes / 60)
      var minutes = Math.floor(totalMinutes % 60)

      function pad2(value) {
        var str = String(value)
        return str.length < 2 ? ("0" + str).slice(-2) : str
      }
      var formattedDifference = (differenceSeconds >= 0 ? "+" : "-") + pad2(hours) + ":" + pad2(minutes)

      return {
        operation           : op,
        referenceIso8601    : String(base.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        firstTimezone       : String(firstZone.getId()),
        secondTimezone      : String(secondZone.getId()),
        firstOffsetSeconds  : Number(firstOffset),
        secondOffsetSeconds : Number(secondOffset),
        differenceSeconds   : Number(differenceSeconds),
        differenceHours     : Number(differenceSeconds / 3600),
        differenceFormatted : formattedDifference
      }
    }

    throw new Error("Unsupported operation: " + op)

# ------------
- name : Sleep
  check:
    in:
      milliseconds: isNumber
  exec : | #js
    var duration = Number(args.milliseconds)
    if (!isFinite(duration) || duration < 0) {
      throw new Error("milliseconds must be a non-negative number")
    }

    sleep(duration, true)

    return {
      sleptMilliseconds: duration
    }
