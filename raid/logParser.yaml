# Author: Nuno Aguiar
help:
  text   : Reads a ndjson logs file and converts it to readable human logs (version 20221003)
  expects:
  - name     : file
    desc     : "The file path to the ndjson log files (either .ndjson or .ndjson.gz)"
    example  : logs_12345.ndjson.gz
    mandatory: false
  - name     : filter
    desc     : "Comma separated pairs of field value filters (for example: \"field1:abc,field2:xyz\")"
    example  : field1:abc,field2:xyz
    mandatory: false
  - name     : notfilter
    desc     : "Comma separated pairs of field value not filters (for example: \"field1:abc,field2:xyz\")"
    example  : field1:abc,field2:xyz
    mandatory: false
  - name     : type
    desc     : "If you want to specify any longer not included by default (for example: AuditLogger)"
    example  : AuditLogger
    mandatory: false
  - name     : icase
    desc     : "If icase=false then filters will be case sensitive (default: icase=true)"
    example  : "false"
    mandatory: false
  - name     : inception
    desc     : "If inception=true it will handle cases where JSON is included in the message field (default: inception=true)"
    example  : "true"
    mandatory: false

init:
  templateAudit  : "{{_time}} [{{$f '%-20.20s' thread_name}}] {{$f '%-5s' level}} {{code}} [{{executionId}}] - {{clientType}}, {{clientVersion}}, {{clientUsername}}, {{remoteIP}}, {{remoteHostname}}, {{clientIP}}, {{clientHostname}}, {{referrer}}, {{username}}, {{sessionId}}, {{activityType}}, {{activityName}}, {{activityDescr}}, {{result}}, {{errorCode}}, {{failureDescr}}, {{operationTime}} {{stack_trace}}"
  templateRegular: "{{_time}} [{{$f '%-20.20s' thread_name}}] {{$f '%-5s' level}} {{code}} [{{executionId}}] - {{{message}}} {{{stack_trace}}}"
  templateDefault: "{{_time}} | {{level }} | {{{message}}}"

todo:
- Read ndjson log file

ojob:
  sequential  : true
  opacks      :
  - openaf: 20220510
  catch       : |
    printErr("ERROR: " + exception)
  logToConsole: false   # to change when finished

jobs:
# ---------------------------
- name : Read ndjson log file
  check:
    in:
      file     : isString.default(__)
      filter   : isString.default(__)
      notfilter: isString.default(__)
      type     : isString.default(__)
      icase    : toBoolean.isBoolean.default(true)
      inception: toBoolean.isBoolean.default(true)
  exec : |
    var is
    ow.loadTemplate()
    ow.template.addFormatHelpers()
    ow.template.addOpenAFHelpers()
    ow.template.addConditionalHelpers()

    if (isDef(args.file)) {
      if (args.file.endsWith(".ndjson"))    is = io.readFileStream(args.file)
      if (args.file.endsWith(".ndjson.gz")) is = io.readFileGzipStream(args.file)

      if (isUnDef(is)) throw "Can't recognize file '" + args.file + "' as a ndjson or ndjson.gz"
    }

    // Compile templates
    var tmplAudit   = ow.template.execCompiled(ow.template.compile(args.init.templateAudit))
    var tmplRegular = ow.template.execCompiled(ow.template.compile(args.init.templateRegular))
    var tmplDefault = ow.template.execCompiled(ow.template.compile(args.init.templateDefault))

    var buf = __
    global.wildcardTest = (str, pattern, caseSensitive) => {
        caseSensitive = _$(caseSensitive).isBoolean().default(false)
        var w = "^" + pattern.replace(/[.+^${}()|[\]\\]/g, '\\$1').replace(/\*/g, '.*').replace(/\?/g, '.') + "$"
        return (new RegExp(w, (caseSensitive ? __ : 'i'))).test(str)
    }
    global.parseLine = line => {
      if (isUnDef(buf) && line.length != 0 && line.trim().startsWith("{")) buf = ""
      if (isDef(buf)) {
        if (line.length != 0 && !line.trim().endsWith("}")) { buf += line.trim(); return }
        if (buf.length > 0) { line = buf + line; buf = __ }
      }
      if (line.length == 0 || line.length > 0 && line.trim().substring(0, 1) != "{") { 
        if (isUnDef(args.filter) && isUnDef(args.notfilter) && isUnDef(args.type)) print(line) 
        buf = __
        return 
      }

      var data, go = true
      try { 
        data = jsonParse(line)
        // Test for "inception"
        if (args.inception && isMap(data) && isString(data.message) && data.message.startsWith("{") && data.message.endsWith("}")) data = jsonParse(data.message)
      } catch(e) { 
        sprintErr(e) 
      }
      if (!isMap(data)) { if (isUnDef(args.filter) && isUnDef(args.notfilter) && isUnDef(args.type)) print(data); return }
      if (isString(args.filter)) {
        if (args.filter.indexOf("*") >= 0 || args.filter.indexOf("?") >= 0) {
          args.filter.split(",").forEach(f => {
            var ar = f.split(":")
            if (isUnDef(data[ar[0]]) || !global.wildcardTest(data[ar[0]], ar[1], !args.icase) ) go = false
          })
        } else {
          args.filter.split(",").forEach(f => {
            var ar = f.split(":")
            if (isUnDef(data[ar[0]]) || String(data[ar[0]]) != String(ar[1])) go = false
          })
        }
      }
      if (isString(args.notfilter)) {
        if (args.notfilter.indexOf("*") >= 0 || args.notfilter.indexOf("?") >= 0) {
          args.notfilter.split(",").forEach(f => {
            var ar = f.split(":")
            if (isDef(data[ar[0]]) && global.wildcardTest(data[ar[0]], ar[1], !args.icase) ) go = false
          })
        } else {
          args.notfilter.split(",").forEach(f => {
            var ar = f.split(":")
            if (isDef(data[ar[0]]) && String(data[ar[0]]) == String(ar[1])) go = false
          })
        }
      }

      if (isDef(args.type) && data.logger_name != args.type) go = false
      if (isUnDef(args.type) && data.logger_name == "AuditLogger") go = false

      if (go) {
        if (isString(data["@timestamp"]) && data["@timestamp"].indexOf("T") > 0 && data["@timestamp"].indexOf(".") > 0 && data["@timestamp"].endsWith("Z")) data["@timestamp"] = ow.format.toDate(data["@timestamp"], "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        switch(data.logger_name) {
        case "AuditLogger":
          try { data._time = ow.format.fromDate(new Date(isDef(data.parse_timestamp) ? data.parse_timestamp : data["@timestamp"]), "yyyy-MM-dd HH:mm:ss,SSS") } catch(e2) { data._time = data.parse_timestamp }
          data.thread_name = data.thread_name.substr(-20)
          print(tmplAudit(data))
          break;
        default           :
          try {
            if (isUnDef(data.code)) {
              try { data._time = ow.format.fromDate(new Date(isDef(data.parse_timestamp) ? data.parse_timestamp : data["@timestamp"]), "yyyy-MM-dd HH:mm:ss,SSS") } catch(e2) { data._time = data.parse_timestamp }
              if (isDef(data["thread_name"])) data.message = "[" + data["thread_name"] + "] " + data.message
              print(tmplDefault(data))
            } else {
              try { data._time = ow.format.fromDate(new Date(isDef(data.parse_timestamp) ? data.parse_timestamp : data["@timestamp"]), "yyyy-MM-dd HH:mm:ss,SSS") } catch(e2) { data._time = data.parse_timestamp }
              data.thread_name = data.thread_name.substr(-20)
              print(tmplRegular(data))
            }
          } catch(e) {
            printErr("ERROR | " + e + " | record = " + af.toSLON(data))
          }
        }
      }
    }

    if (isDef(args.file)) {
      ioStreamReadLines(is, global.parseLine, "\n")
      is.close()
    } else {
      io.pipeLn(global.parseLine)
    }